<p align="center">
  <p align="center">
    <a href="https://app.val.build">
<svg width="100" height="100" viewBox="0 0 944 944" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="472" cy="472" r="472" fill="#1D1C28"/>
<g filter="url(#filter0_d_14_601)">
<path d="M181 348C181 345.791 182.791 344 185 344H320C322.209 344 324 345.791 324 348V602C324 604.209 322.209 606 320 606H185C182.791 606 181 604.209 181 602V348Z" fill="#38CD80"/>
</g>
<g filter="url(#filter1_i_14_601)">
<circle cx="252" cy="550" r="24" fill="#1E1F2A"/>
</g>
<path d="M659.085 550.374H658.585H654.427C652.095 550.374 650.434 549.729 649.347 548.522C648.25 547.306 647.658 545.431 647.658 542.807V439.857C647.658 437.924 646.091 436.357 644.158 436.357H629.16C627.227 436.357 625.66 437.924 625.66 439.857V455.828C625.66 456.658 624.986 457.332 624.155 457.332C623.593 457.332 623.072 457.015 622.798 456.508C618.502 448.559 612.704 442.661 605.399 438.838C597.962 434.671 589.622 432.592 580.394 432.592C571.897 432.592 563.846 434.128 556.247 437.2C548.643 440.274 541.944 444.796 536.154 450.761L536.153 450.761C530.537 456.552 526.106 463.693 522.854 472.174C519.598 480.668 517.975 490.411 517.975 501.395V505.697C517.975 516.86 519.597 526.693 522.854 535.187C526.105 543.667 530.535 550.895 536.148 556.864L536.153 556.869L536.159 556.875C541.95 562.659 548.647 567.088 556.246 570.161L556.256 570.165C563.856 573.057 572.083 574.5 580.932 574.5C589.456 574.5 597.527 572.325 605.137 567.982C612.625 563.807 618.519 557.469 622.822 548.992C623.085 548.475 623.609 548.147 624.176 548.147H624.546C625.161 548.147 625.66 548.646 625.66 549.261C625.66 555.468 627.583 560.617 631.452 564.665L631.451 564.665L631.46 564.673C635.511 568.72 640.668 570.735 646.889 570.735H658.585H659.085H661.157H661.657H760C761.933 570.735 763.5 569.168 763.5 567.235V553.874C763.5 551.941 761.933 550.374 760 550.374H733.542C732.161 550.374 731.042 549.255 731.042 547.874V385C731.042 383.067 729.475 381.5 727.542 381.5H680.701C678.768 381.5 677.201 383.067 677.201 385V398.361C677.201 400.294 678.768 401.861 680.701 401.861H706.543C707.924 401.861 709.043 402.981 709.043 404.361V547.874C709.043 549.255 707.924 550.374 706.543 550.374H661.657H661.157H659.085ZM600.117 550.146L600.111 550.149C594.977 552.448 589.304 553.601 583.086 553.601C570.468 553.601 560.194 549.435 552.222 541.12C544.436 532.633 540.512 520.847 540.512 505.697V501.395C540.512 494.274 541.581 487.79 543.712 481.936L543.714 481.931C545.849 475.89 548.778 470.842 552.495 466.775C556.398 462.521 560.92 459.246 566.061 456.944C571.195 454.645 576.867 453.492 583.086 453.492C589.117 453.492 594.696 454.731 599.829 457.207L599.838 457.211L599.848 457.215C605.166 459.517 609.681 462.79 613.4 467.035L613.4 467.035L613.408 467.044C617.306 471.292 620.324 476.431 622.458 482.469L622.459 482.474C624.59 488.328 625.66 494.812 625.66 501.933V505.16C625.66 512.46 624.59 519.125 622.458 525.159C620.324 531.022 617.393 536.075 613.669 540.326C609.95 544.571 605.435 547.844 600.117 550.146ZM464.902 570.735C466.39 570.735 467.716 569.794 468.206 568.389L512.685 441.011C513.479 438.736 511.79 436.357 509.38 436.357H491.006C489.496 436.357 488.157 437.325 487.683 438.758L447.951 558.864C447.716 559.575 447.051 560.055 446.303 560.055C445.554 560.055 444.89 559.575 444.655 558.864L404.923 438.758C404.449 437.325 403.109 436.357 401.6 436.357H383.225C380.815 436.357 379.126 438.736 379.921 441.011L424.399 568.389C424.89 569.794 426.215 570.735 427.704 570.735H464.902Z" fill="white" stroke="white"/>
<defs>
<filter id="filter0_d_14_601" x="127.464" y="290.464" width="250.072" height="369.072" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="26.768"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.219608 0 0 0 0 0.803922 0 0 0 0 0.501961 0 0 0 0.3 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_14_601"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_14_601" result="shape"/>
</filter>
<filter id="filter1_i_14_601" x="228" y="526" width="48" height="48" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="6"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.219608 0 0 0 0 0.803922 0 0 0 0 0.501961 0 0 0 0.3 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_14_601"/>
</filter>
</defs>
</svg>
    </a>
    <br/>
  </p>
</p>

# 🐉 HERE BE DRAGONS 🐉

Val is currently in beta - the API can be considered relatively stable, but expect some features to be broken and the UX to be changing.

Join us on [discord](https://discord.gg/cZzqPvaX8k) to get help or give us feedback.

## Table of contents

- [Installation](#installation)
- [Getting started](#getting-started)
- [Schema types](#schema-types):
  - [String](#string)
  - [Number](#number)
  - [Boolean](#boolean)
  - [Nullable](#nullable)
  - [Array](#array)
  - [Record](#record)
  - [Object](#object)
  - [Rich text](#richtext)
  - [Image](#image)
  - [keyOf](#keyof)

## Installation

### Using the starter template

If you're starting from scratch, the easiest way to get up and running with Val is to use npm (or similar) create script:

```sh
npm create @valbuild
```

This will setup Val on a default Next.JS template and is the fastest way to get started with Val.

### Integrating into an existing project

- Make sure you have setup a NextJS (version 14 or higher) project.

- Install the packages:

```sh
npm install @valbuild/core@latest @valbuild/next@latest
```

- Optionally, but recommend add the eslint-plugin package:

```sh
npm install -D  @valbuild/eslint-plugin@latest
```

- Run the init script:

```sh
npx @valbuild/init@latest
```

### Manually

It is also possible to setup Val using the [manual configuration guide](./MANUAL_CONFIGURATION.md).

## Additional setup

- If you have a monorepo, or have a project where the project is located in a subdirectory relative to the github repository see the [monorepos](#monorepos) section
- See [formatting published content](#formatting-published-content) if you use prettier (or similar) Val to do it as well.
- If you want editors to update content in production, read up on how to setup [remote mode](#remote-mode).

## Getting started

### Create your first Val content file

Content in Val is always defined in `.val.ts` (or `.js`) files.

**NOTE**: the init script will generate an example Val content file (unless you opt out of it).

Val content files are _evaluated_ by Val, therefore they need to abide a set of requirements.
If you use the eslint plugins these requirements will be enforced. You can also validate val files using the @valbuild/cli: `npx -p @valbuild/cli val validate`.

For reference these requirements are:

- they must export a default content definition (`c.define`) where the first argument equals the path of the file relative to the `val.config` file; and
- they must be declared in the `val.modules` file; and
- they must have a default export that is `c.define`; and
- they can only import Val related files or types (using `import type { MyType } from "./otherModule.ts"`)

### Val content file example

```ts
// ./examples/val/example.val.ts
import { s /* s = schema */, c /* c = content */ } from "../../val.config";

/**
 * This is the schema for the content. It defines the structure of the content and the types of each field.
 */
export const schema = s.object({
  /**
   * Basic text field
   */
  text: s.string(),
});

/**
 * This is the content definition. Add your content below.
 *
 * NOTE: the first argument is the path of the file.
 */
export default c.define("/examples/val/example.val.ts", schema, {
  text: "Basic text content",
});
```

### The `val.modules` file

Once you have created your Val content file, it must be declared in the `val.modules.ts` (or `.js`) file in the project root folder.

Example:

```ts
import { modules } from "@valbuild/next";
import { config } from "./val.config";

export default modules(config, [
  // Add your modules here
  { def: () => import("./examples/val/example.val") },
]);
```

### Using Val in Client Components

In client components you can access your content with the `useVal` hook:

```tsx
// ./app/page.tsx
"use client";
import { useVal } from "../val/val.client";
import exampleVal from "../examples/val/example.val";

export default function Home() {
  const { text } = useVal(exampleVal);
  return <main>{text}</main>;
}
```

### Using Val in React Server Components

In React Server components you can access your content with the `fetchVal` function:

```tsx
// ./app/page.tsx
"use server";
import { fetchVal } from "../val/val.rsc";
import exampleVal from "../examples/val/example.val";

export default async function Home() {
  const { text } = await fetchVal(exampleVal);
  return <main>{text}</main>;
}
```

# Remote Mode

Enable remote mode to allow editors to update content online (outside of local development) by creating a project at [app.val.build](https://app.val.build).

**NOTE**: Your content remains yours. Hosting content from your repository does not require a subscription. However, to edit content online, a subscription is needed — unless your project is a public repository or qualifies for the free tier. Visit the [pricing page](https://val.build/pricing) for details.

**WHY**: Updating code involves creating a commit, which requires a server. We offer a hosted service for simplicity and efficiency, as self-hosted solutions takes time to setup and maintain. Additionally, the [val.build](https://val.build) team funds the ongoing development of this library.

## Remote Mode Configuration

Once your project is set up in [app.val.build](https://app.val.build), configure your application to use it by setting the following:

### Environment Variables

- **`VAL_API_KEY`**: This is the API key used to authenticate server side API requests. You can find it under Settings in your project on [app.val.build](https://app.val.build).
- **`VAL_SECRET`**: In addition to the VAL_API_KEY, you need to generate a random secret to secure communication between the UX client and your Next.js application. You can use any random string for this, but if you have openssl installed you can run the following command: `openssl rand -hex 16`

### `val.config` Properties

Set these properties in the `val.config` file:

- **`project`**: The fully qualified name of your project, formatted as `<team>/<name>`.
- **`gitBranch`**: The Git branch your application uses. For Vercel, use `VERCEL_GIT_COMMIT_REF`.
- **`gitCommit`**: The current Git commit your application is running on. For Vercel, use `VERCEL_GIT_COMMIT_SHA`.
- **`root`**: Optional. The path to the `val.config` file. Typically empty or undefined. If the project folder is under `web`, root would be: `/web`.

### Example `val.config.ts`

```ts
import { initVal } from "@valbuild/next";

const { s, c, val, config } = initVal({
  project: "myteam/myproject",
  //root: "/subdir", // only required for monorepos. Use the path where val.config is located. The path should start with /
  gitBranch: process.env.VERCEL_GIT_COMMIT_REF,
  gitCommit: process.env.VERCEL_GIT_COMMIT_SHA,
});

export type { t } from "@valbuild/next";
export { s, c, val, config };
```

# Formatting published content

If you are using `prettier` or another code formatting tool, it is recommended to setup formatting of code after changes have been applied.

## Setting up formatting using Prettier

- Install `prettier` as **RUNTIME** dependency, by moving the `prettier` dependency from `devDependencies` to `dependencies`. The reason you need to do this, is that Val will be using it at runtime in production, and it has to be part of your build for this to work.
- Optionally create a `.prettierrc.json` file unless you have one already. We recommend doing this, so that you can be sure that formatting is applied consistently in both your development environment and by Val. You can set this to be an empty object, if you are want to keep using `prettier`s defaults:

  ```json
  {}
  ```

- Add a formatter to the `/val/val.server`:

  ```ts
  formatter: (code: string, filePath: string) => {
    return prettier.format(code, {
      filepath: filePath,
      ...prettierOptions, // <- use the same rules as in development
    } as prettier.Options);
  },
  ```

  Unless you have any modifications in your `val.server` file, the complete file should now look like this:

  ```ts
  import "server-only";
  import { initValServer } from "@valbuild/next/server";
  import { config } from "../val.config";
  import { draftMode } from "next/headers";
  import valModules from "../val.modules";
  import prettier from "prettier";
  import prettierOptions from "../.prettierrc.json";

  const { valNextAppRouter } = initValServer(
    valModules,
    { ...config },
    {
      draftMode,
      formatter: (code: string, filePath: string) => {
        return prettier.format(code, {
          filepath: filePath,
          ...prettierOptions, // <- use the same rules as in development
        } as prettier.Options);
      },
    },
  );

  export { valNextAppRouter };
  ```

You should now be able to hit the save button locally and see prettier rules being applied.

## Other formatters

Val is formatter agnostic, so it is possible to use the same flow as the one described for `prettier` above to any formatter you might want to use.

**NOTE**: this will be applied at runtime in production so you need make sure that the formatting dependencies are in the `dependencies` section of your `package.json`

# Monorepos

Val supports projects that are not under the root path in GitHub, and therefore monorepos.
To configure your project for monorepos, you can use the `root` parameter described in the [config](#valconfig-properties) section.

# Schema types

## String

```ts
import { s } from "./val.config";

s.string(); // <- Schema<string>
```

## Number

```ts
import { s } from "./val.config";

s.number(); // <- Schema<number>
```

## Boolean

```ts
import { s } from "./val.config";

s.boolean(); // <- Schema<boolean>
```

## Nullable

All schema types can be nullable (optional). A nullable schema creates a union of the type and `null`.

```ts
import { s } from "./val.config";

s.string().nullable(); // <- Schema<string | null>
```

## Array

```ts
s.array(t.string()); // <- Schema<string[]>
```

## Record

The type of `s.record` is `Record`.

It is similar to an array, in that editors can add and remove items in it, however it has a unique key which can be used as, for example, the slug or as a part of an route.

**NOTE**: records can also be used with `keyOf`.

```ts
s.record(t.number()); // <- Schema<Record<string, number>>
```

## Object

```ts
s.object({
  myProperty: s.string(),
});
```

## RichText

<details>
<summary>RichText in Val represented both in code and to the editors as <strong>semantic html5</strong>.</summary>

This means that content will be accessible and according to spec out of the box. The flip-side is that Val will not support RichText that includes elements that is not part of the html 5 standard.

This opinionated approach was chosen since rendering anything, makes it hard for developers to maintain and hard for editors to understand.

</details>

### RichText Schema

```ts
s.richtext({
  // options
});
```

### Initializing RichText content

To initialize some text content using a RichText schema, you can use follow the example below:

```ts
import { s, c } from "./val.config";

export const schema = s.richtext({
  // styling
  style: {
    bold: true, // enables bold
    italic: true, // enables italic text
    lineThrough: true, // enables line/strike-through
  },
  // tags:
  block: {
    //ul: true, // enables unordered lists
    //ol: true, // enables ordered lists
    // headings:
    h1: true,
    h2: true,
    // h3: true,
    // h4: true,
    // h5: true,
    // h6: true
  },
  inline: {
    //a: true, // enables links
    //img: true, // enables images
  },
});

export default c.define("/src/app/content", schema, [
  {
    tag: "p",
    children: ["This is richtext"],
  },
  {
    tag: "p",
    children: [{ tag: "span", styles: ["bold"], children: ["Bold"] }, "text"],
  },
]);
```

### Rendering RichText

You can use the `ValRichText` component to render content.

```tsx
"use client";
import { ValRichText } from "@valbuild/next";
import contentVal from "./content.val";
import { useVal } from "./val/val.client";

export default function Page() {
  const content = useVal(contentVal);
  return (
    <main>
      <ValRichText
        theme={{
          style: {
            bold: "font-bold", // <- maps bold to a class. NOTE: tailwind classes are supported
          },
          //
        }}
      >
        {content}
      </ValRichText>
    </main>
  );
}
```

#### ValRichText: theme property

To add classes to `ValRichText` you can use the theme property:

```tsx
<ValRichText
  theme={{
    p: "font-sans",
    // etc
  }}
>
  {content}
</ValRichText>
```

**NOTE**: if a theme is defined, you must define a mapping for every tag that the you get. What tags you have is decided based on the `options` defined on the `s.richtext()` schema. For example: `s.richtext({ style: { bold: true } })` requires that you add a `bold` theme.

```tsx
<ValRichText
  theme={{
    h1: "text-4xl font-bold",
    bold: "font-bold",
    img: null, // either a string or null is required
  }}
>
  {content}
</ValRichText>
```

**NOTE**: the reason you must define themes for every tag that the RichText is that this will force you to revisit the themes that are used if the schema changes. The alternative would be to accept changes to the schema.

### ValRichText: transform property

Vals `RichText` type maps RichText 1-to-1 with semantic HTML5.

If you want to customize / override the type of elements which are rendered, you can use the `transform` property.

```tsx
<ValRichText
  transform={(node, _children, className) => {
    if (typeof node !== "string" && node.tag === "img") {
      return (
        <div className="my-wrapper-class">
          <img {...node} className={className} />
        </div>
      );
    }
    // if transform returns undefined the default render will be used
  }}
>
  {content}
</ValRichText>
```

### The RichText type

The `RichText` type is actually an AST (abstract syntax tree) representing semantic HTML5 elements.

That means they look something like this:

```ts
type RichTextNode = {
  tag:
    | "img"
    | "a"
    | "ul"
    | "ol"
    | "h1"
    | "h2"
    | "h3"
    | "h4"
    | "h5"
    | "h6"
    | "br"
    | "p"
    | "li"
    | "span";
  classes: "bold" | "line-through" | "italic"; // all styling classes
  children: RichTextNode[] | undefined;
};
```

### RichText: full custom

The `RichText` type maps 1-to-1 to HTML.
That means it is straightforward to build your own implementation of a React component that renders `RichText`.

This example is a simplified version of the `ValRichText` component.
You can use this as a template to create your own.

NOTE: before writing your own, make sure you check out the `theme` and `transform` properties on the `ValRichText` - most simpler cases should be covered by them.

```tsx
export function ValRichText({
  children: root,
}: {
  children: RichText<MyRichTextOptions>;
}) {
  function build(
    node: RichTextNode<MyRichTextOptions>,
    key?: number,
  ): JSX.Element | string {
    if (typeof node === "string") {
      return node;
    }
    // you can map the classes to something else here
    const className = node.classes.join(" ");
    const tag = node.tag; // one of: "img" | "a" | "ul" | "ol" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "br" | "p" | "li" | "span"

    // Example of rendering img with MyOwnImageComponent:
    if (tag === "img") {
      return <MyOwnImageComponent {...node} />;
    }
    return React.createElement(
      tag,
      {
        key,
        className,
      },
      "children" in node ? node.children.map(build) : null,
    );
  }
  return <div {...val.attrs(root)}>{root.children.map(build)}</div>;
}
type MyRichTextOptions = AnyRichTextOptions; // you can reduce the surface of what you need to render, by restricting the `options` in `s.richtext(options)`
```

## Image

### Image Schema

```ts
s.image();
```

### Initializing image content

Local images must be stored under the `/public/val` folder.

```ts
import { s, c } from "../val.config";

export const schema = s.image();

export default c.define("/image", schema, c.image("/public/myfile.jpg"));
```

**NOTE**: This will not validate, since images requires `width`, `height` and `mimeType`. You can fix validation errors like this by using the CLI or by using the VS Code plugin.

### Rendering images

The `ValImage` component is a wrapper around `next/image` that accepts a Val `Image` type.

You can use it like this:

```tsx
const content = useVal(contentVal); // schema of contentVal: s.object({ image: s.image() })

return <ValImage src={content.image} />;
```

### Using images in components

Images are transformed to object that have a `url` property which can be used to render them.

Example:

```tsx
// in a Functional Component
const image = useVal(imageVal);

return <img src={image.url} />;
```

## Union

The union schema can be used to create either "tagged unions" or a union of string literals.

### Union Schema tagged unions

A tagged union is a union of objects which all have the same field (of the same type). This field can be used to determine (or "discriminate") the exact type of one of the types of the union.

It is useful when editors should be able to chose from a set of objects that are different.

Example: let us say you have a page that can be one of the following: blog (page) or product (page). In this case your schema could look like this:

```ts
s.union(
  "type", // the key of the "discriminator"
  s.object({
    type: s.literal("blogPage"), // <- each type must have a UNIQUE value
    author: s.string(),
    // ...
  }),
  s.object({
    type: s.literal("productPage"),
    sku: s.number(),
    // ...
  }),
); // <- Schema<{ type: "blogPage", author: string } | { type: "productPage", sku: number }>
```

## Union Schema: union of string literals

You can also use a union to create a union of string literals. This is useful if you want a type-safe way to describe a set of valid strings that can be chosen by an editor.

```ts
s.union(
  s.literal("one"),
  s.literal("two"),
  //...
); // <- Schema<"one" | "two">
```

## KeyOf

You can use `keyOf` to reference a key in a record of a Val module.

**NOTE**: currently you must reference keys in Val modules, you cannot reference keys of values nested inside a Val module. This is a feature on the roadmap.

```ts
const schema = s.record(s.object({ nested: s.record(s.string()) }));

export default c.define("/keyof.val.ts", schema, {
  "you-can-reference-me": {
    // <- this can be referenced
    nested: {
      "but-not-me": ":(", // <- this cannot be referenced
    },
  },
});
```

### KeyOf Schema

```ts
import otherVal from "./other.val"; // NOTE: this must be a record

s.keyOf(otherVal);
```

### Initializing keyOf

### Using keyOf to reference content

```tsx
const article = useVal(articleVal); // s.object({ author: s.keyOf(otherVal) })
const authors = useVal(otherVal); // s.record(s.object({ name: s.string() }))

const nameOfAuthor = authors[articleVal.author].name;
```
