<p align="center">
  <p align="center">
    <a href="https://app.val.build">
<svg width="100" height="100" viewBox="0 0 944 944" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="472" cy="472" r="472" fill="#1D1C28"/>
<g filter="url(#filter0_d_14_601)">
<path d="M181 348C181 345.791 182.791 344 185 344H320C322.209 344 324 345.791 324 348V602C324 604.209 322.209 606 320 606H185C182.791 606 181 604.209 181 602V348Z" fill="#38CD80"/>
</g>
<g filter="url(#filter1_i_14_601)">
<circle cx="252" cy="550" r="24" fill="#1E1F2A"/>
</g>
<path d="M659.085 550.374H658.585H654.427C652.095 550.374 650.434 549.729 649.347 548.522C648.25 547.306 647.658 545.431 647.658 542.807V439.857C647.658 437.924 646.091 436.357 644.158 436.357H629.16C627.227 436.357 625.66 437.924 625.66 439.857V455.828C625.66 456.658 624.986 457.332 624.155 457.332C623.593 457.332 623.072 457.015 622.798 456.508C618.502 448.559 612.704 442.661 605.399 438.838C597.962 434.671 589.622 432.592 580.394 432.592C571.897 432.592 563.846 434.128 556.247 437.2C548.643 440.274 541.944 444.796 536.154 450.761L536.153 450.761C530.537 456.552 526.106 463.693 522.854 472.174C519.598 480.668 517.975 490.411 517.975 501.395V505.697C517.975 516.86 519.597 526.693 522.854 535.187C526.105 543.667 530.535 550.895 536.148 556.864L536.153 556.869L536.159 556.875C541.95 562.659 548.647 567.088 556.246 570.161L556.256 570.165C563.856 573.057 572.083 574.5 580.932 574.5C589.456 574.5 597.527 572.325 605.137 567.982C612.625 563.807 618.519 557.469 622.822 548.992C623.085 548.475 623.609 548.147 624.176 548.147H624.546C625.161 548.147 625.66 548.646 625.66 549.261C625.66 555.468 627.583 560.617 631.452 564.665L631.451 564.665L631.46 564.673C635.511 568.72 640.668 570.735 646.889 570.735H658.585H659.085H661.157H661.657H760C761.933 570.735 763.5 569.168 763.5 567.235V553.874C763.5 551.941 761.933 550.374 760 550.374H733.542C732.161 550.374 731.042 549.255 731.042 547.874V385C731.042 383.067 729.475 381.5 727.542 381.5H680.701C678.768 381.5 677.201 383.067 677.201 385V398.361C677.201 400.294 678.768 401.861 680.701 401.861H706.543C707.924 401.861 709.043 402.981 709.043 404.361V547.874C709.043 549.255 707.924 550.374 706.543 550.374H661.657H661.157H659.085ZM600.117 550.146L600.111 550.149C594.977 552.448 589.304 553.601 583.086 553.601C570.468 553.601 560.194 549.435 552.222 541.12C544.436 532.633 540.512 520.847 540.512 505.697V501.395C540.512 494.274 541.581 487.79 543.712 481.936L543.714 481.931C545.849 475.89 548.778 470.842 552.495 466.775C556.398 462.521 560.92 459.246 566.061 456.944C571.195 454.645 576.867 453.492 583.086 453.492C589.117 453.492 594.696 454.731 599.829 457.207L599.838 457.211L599.848 457.215C605.166 459.517 609.681 462.79 613.4 467.035L613.4 467.035L613.408 467.044C617.306 471.292 620.324 476.431 622.458 482.469L622.459 482.474C624.59 488.328 625.66 494.812 625.66 501.933V505.16C625.66 512.46 624.59 519.125 622.458 525.159C620.324 531.022 617.393 536.075 613.669 540.326C609.95 544.571 605.435 547.844 600.117 550.146ZM464.902 570.735C466.39 570.735 467.716 569.794 468.206 568.389L512.685 441.011C513.479 438.736 511.79 436.357 509.38 436.357H491.006C489.496 436.357 488.157 437.325 487.683 438.758L447.951 558.864C447.716 559.575 447.051 560.055 446.303 560.055C445.554 560.055 444.89 559.575 444.655 558.864L404.923 438.758C404.449 437.325 403.109 436.357 401.6 436.357H383.225C380.815 436.357 379.126 438.736 379.921 441.011L424.399 568.389C424.89 569.794 426.215 570.735 427.704 570.735H464.902Z" fill="white" stroke="white"/>
<defs>
<filter id="filter0_d_14_601" x="127.464" y="290.464" width="250.072" height="369.072" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="26.768"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.219608 0 0 0 0 0.803922 0 0 0 0 0.501961 0 0 0 0.3 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_14_601"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_14_601" result="shape"/>
</filter>
<filter id="filter1_i_14_601" x="228" y="526" width="48" height="48" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="6"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.219608 0 0 0 0 0.803922 0 0 0 0 0.501961 0 0 0 0.3 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_14_601"/>
</filter>
</defs>
</svg>
    </a>
    <br/>
  </p>
</p>

# üêâ HERE BE DRAGONS üêâ

Val is PRE-ALPHA - MOST features are broken and in state of flux.

This is release is only for **INTERNAL** **TESTING** PURPOSES.

## Table of contents

- [Introduction](#introduction)
- [Installation](#installation)
- [Getting started](#getting-started)
- [Schema types](#schema-types):
  - [String](#string)
  - [Number](#number)
  - [Boolean](#boolean)
  - [Optional](#optional)
  - [Array](#array)
  - [Record](#record)
  - [Object](#object)
  - [Rich text](#richtext)
  - [Image](#image)
  - [keyOf](#keyof)

## Introduction

Val is a CMS where **content** is **code** stored in your git repo.

As a CMS, Val is useful because:

- editors can **change content** without having to ask developers to do it for them (and nobody wants that)
- a **well-documented** way to **structure content**
- **image** support is built-in
- **richtext** support is built-in
- built-in **visual editing** which lets editors click-then-edit content (and therefore **code**!) directly in your app

  ![Visual editing](https://val.build/docs/images/overlay.png)

<details>
<summary>Definition: editor</summary>
An editor in this context, is a non-technical person that edits content in your application (technical writer, proof-reader, legal, ...).
</details>

<br />

But, with the benefits of **hard-coded** content:

- works seamlessly **locally** or with git **branches**
- content is **type-checked** so you can spend less time on figuring out why something isn't working
  ![Type check error](https://val.build/docs/images/type-check-error.png)
- content can be refactored (change names, etc) just as if it was hard-coded (because it is)
  ![Renaming](https://val.build/docs/images/renaming.gif)
- works as normal with your **favorite IDE** without any plugins: search for content, references to usages, ...
  ![References](https://val.build/docs/images/references.gif)
- **no** need for **code-gen** and extra build steps
- **fast** since the content is literally hosted with the application
- content is **always there** and can never fail (since it is not loaded from somewhere)
- no need to manage different **environments** containing different versions of content
- **resolve conflicts** like you normally resolve conflicts: **in git**

Compared to other CMSs, Val has the following advantages:

- **easy** to setup and to _grok_: Val is designed to have a minimum of boilerplate and there's **0** query languages to learn. If you know your way around JSON that's enough (if you don't you might want to learn it)
- **no signup** required to use it locally
- **no fees** for content that is in your code: your content is your code, and your code is... yours
- **minimal** API surface: Val is designed to not "infect" your code base
- **easy to remove**: since your content is already in your code and Val is designed to have a minimal surface, it's easy to remove if you want to switch

<details>
<summary>Upcoming feature: <strong>i18n</strong></summary>
Val will soon have support for i18n. Follow this repository to get notified when this is the case.
</details>

<details>
<summary>Upcoming feature: <strong>remote content</strong></summary>
Having hard-coded content is great for landing pages, product pages and other pages where the amount of content is manageable.

However, checking in the 10 000th blog entry in git might feel wrong (though we would say it is ok).

Therefore, Val will add `remote content` support which enables you to seamlessly move content to the cloud and back again as desired.
You code will still be the one truth, but the actual content will be hosted on [val.build](https://val.build).

`.remote()` support will also make it possible to have remote images to avoid having to put them in your repository.

There will also be specific support for remote i18n, which will make it possible to split which languages are defined in code, and which are fetched from remote.

More details on `.remote()` will follow later.

</details>

## When to NOT use Val

Val is designed to work well on a single web-app, and currently only supports Next 13.4+ (more meta-frameworks will supported) and GitHub (more Git providers will follow).

Unless your application fits these requirements, you should have a look elsewhere (at least for now).

In addition, if you have a "content model", i.e. content schemas, that rarely change and you plan on using them in a lot of different applications (web, mobile, etc), Val will most likely not be a great fit.

If that is the case, we recommend having a look at [sanity](https://sanity.io) instead (we have no affiliation, but if we didn't have Val we would use Sanity).

**NOTE**: Our experience is that, however nice it sounds, it is hard to "nail" the content model down. Usually content is derived from what you want to present, not vice-versa. In addition, you should think carefully whether you _really_ want to present the exact same content on all these different surfaces.

## Examples

Check out this README or the [examples](./examples) directory for examples.

## Installation

- Make sure you have TypeScript 5+, Next 13.4+ (other meta frameworks will come), React 18.20.+ (other frontend frameworks will come)
- Install the packages (@valbuild/eslint-plugin is recommended but not required):

```sh
npm install @valbuild/core@latest @valbuild/next@latest @valbuild/eslint-plugin@latest
```

- Run the init script:

```sh
npx @valbuild/init@latest
```

### Add editor support

To make it possible to do non-local edits, head over to [val.build](https://val.build), sign up and import your repository.

**NOTE**: your content is yours. No subscription (or similar) is required to host content from your repository.

If you do not need to edit content online (i.e. not locally), you do not need to sign up.

**WHY**: to update your code, we need to create a commit. This requires a server. We opted to create a service that does this easily, instead of having a self-hosted alternative, since time spent is money used. Also, the company behind [val.build](https://val.build) is the company that funds the development of this software.

## Getting started

### Create your first Val content file

Content in Val is always defined in `.val.ts` files.

**NOTE**: Val also works with `.js` files.

They must export a default content definition (`c.define`) where the first argument equals the path of the file relative to the `val.config.ts` file.

**NOTE**: `val.ts` files are _evaluated_ by Val, therefore they have a specific set of requirements:

- They must have a default export that is `c.define`, they must have a `export const schema` with the Schema; and
- they CANNOT import anything other than `val.config` and `@valbuild/core`

### Example of a `.val.ts` file

```ts
// ./src/app/content.val.ts

import { s, c } from "../../../val.config";

export const schema = s.object({
  title: s.string().optional(), //  <- NOTE: optional()
  sections: s.array(
    s.object({
      title: s.string(),
      text: s.richtext({
        style: {
          bold: true, // <- Enables bold in richtext
        }
      }),
    })
  ),
});

export default c.define(
  "/src/app/content", // <- NOTE: this must be the same path as the file
  schema,
  {
    title: "My Page",
    sections: [
      {
        title: "Section 1",
        text: [
          {
            tag: "p",
            children: [
              "Val is",
              { tag: "span", styles: ["bold"], children: ["awesome"] },
            ],
          },
        ],
      },
    ],
  }
);
```

### Use your content

In client components you can access your content with the `useVal` hook:

**NOTE**: Support for React Server Components and server side rendering will come soon.

```tsx
// ./src/app/page.tsx
"use client";
import { NextPage } from "next";
import { useVal } from "./val/val.client";
import contentVal from "./content.val";

const Page: NextPage = () => {
  const { title, sections } = useVal(contentVal);
  return (
    <main>
      {title && (
        <section>
          <h1>{title}</h1>
        </section>
      )}
      {sections.map((section) => (
        <section>
          <h2>{section.title}</h2>
          <ValRichText
            theme={{
              style: {
                bold: "font-bold",
              }
            }}
          >
            {section.text}
          </ValRichText>
        </section>
      ))}
    </main>
  );
};

export default Page;
```

# Schema types

## String

```ts
import { s } from "./val.config";

s.string(); // <- Schema<string>
```

## Number

```ts
import { s } from "./val.config";

s.number(); // <- Schema<number>
```

## Boolean

```ts
import { s } from "./val.config";

s.boolean(); // <- Schema<boolean>
```

## Optional

All schema types can be optional. An optional schema creates a union of the type and `null`.

```ts
import { s } from "./val.config";

s.string().optional(); // <- Schema<string | null>
```

## Array

```ts
s.array(t.string()); // <- Schema<string[]>
```

## Record

The type of `s.record` is `Record`.

It is similar to an array, in that editors can add and remove items in it, however it has a unique key which can be used as, for example, the slug or as a part of an route.

**NOTE**: records can also be used with `keyOf`.

```ts
s.record(t.number()); // <- Schema<Record<string, number>>
```

## Object

```ts
s.object({
  myProperty: s.string(),
});
```

## RichText

<details>
<summary>RichText in Val represented both in code and to the editors as <strong>semantic html5</strong>.</summary>

This means that content will be accessible and according to spec out of the box. The flip-side is that Val will not support RichText that includes elements that is not part of the html 5 standard.

This opinionated approach was chosen since rendering anything, makes it hard for developers to maintain and hard for editors to understand.

</details>

### RichText Schema

```ts
s.richtext({
  // options
});
```

### Initializing RichText content

To initialize some text content using a RichText schema, you can use follow the example below:

```ts
import { s, c } from "./val.config";

export const schema = s.richtext({
  // styling
  style: {
    bold: true, // enables bold
    italic: true, // enables italic text
    lineThrough: true, // enables line/strike-through
  },
  // tags:
  block: {
    //ul: true, // enables unordered lists
    //ol: true, // enables ordered lists
    // headings:
    h1: true,
    h2: true,
    // h3: true,
    // h4: true,
    // h5: true,
    // h6: true
  },
  inline: {
    //a: true, // enables links
    //img: true, // enables images
  }
});

export default c.define(
  "/src/app/content",
  schema,
  [
    {
      tag: "p",
      children: ["This is richtext"],
    },
    {
      tag: "p",
      children: [{ tag: "span", styles: ["bold"], children: ["Bold"] }, "text"],
    },
  ]
);
```

### Rendering RichText

You can use the `ValRichText` component to render content.

```tsx
"use client";
import { ValRichText } from "@valbuild/next";
import contentVal from "./content.val";
import { useVal } from "./val/val.client";

export default function Page() {
  const content = useVal(contentVal);
  return (
    <main>
      <ValRichText
        theme={{
          style: {
            bold: "font-bold", // <- maps bold to a class. NOTE: tailwind classes are supported
          }
          //
        }}
      >
        {content}
      </ValRichText>
    </main>
  );
}
```

#### ValRichText: theme property

To add classes to `ValRichText` you can use the theme property:

```tsx
<ValRichText
  theme={{
    p: "font-sans",
    // etc
  }}
>
  {content}
</ValRichText>
```

**NOTE**: if a theme is defined, you must define a mapping for every tag that the you get. What tags you have is decided based on the `options` defined on the `s.richtext()` schema. For example: `s.richtext({ headings: ["h1"]; bold: true; img: true})` forces you to map the class for at least: `h1`, `bold` and `img`:

```tsx
<ValRichText
  theme={{
    h1: "text-4xl font-bold",
    bold: "font-bold",
    img: null, // either a string or null is required
  }}
>
  {content satisfies RichText<{ headings: ["h1"]; bold: true; img: true }>}
</ValRichText>
```

**NOTE**: the reason you must define themes for every tag that the RichText is that this will force you to revisit the themes that are used if the schema changes. The alternative would be to accept changes to the schema.

### ValRichText: transform property

Vals `RichText` type maps RichText 1-to-1 with semantic HTML5.

If you want to customize the type of elements which are rendered, you can use the `transform` property.

```tsx
<ValRichText
  transform={(node, _children, className) => {
    if (typeof node !== "string" && node.tag === "img") {
      return (
        <div className="my-wrapper-class">
          <img {...node} className={className} />
        </div>
      );
    }
    // if transform returns undefined the default render will be used
  }}
>
  {content}
</ValRichText>
```

### The RichText type

The `RichText` type is actually an AST (abstract syntax tree) representing semantic HTML5 elements.

That means they look something like this:

```ts
type RichTextNode = {
  tag:
    | "img"
    | "a"
    | "ul"
    | "ol"
    | "h1"
    | "h2"
    | "h3"
    | "h4"
    | "h5"
    | "h6"
    | "br"
    | "p"
    | "li"
    | "span";
  classes: "bold" | "line-through" | "italic"; // all styling classes
  children: RichTextNode[] | undefined;
};
```

### RichText: full custom

The `RichText` type maps 1-to-1 to HTML.
That means it is straightforward to build your own implementation of a React component that renders `RichText`.

This example is a simplified version of the `ValRichText` component.
You can use this as a template to create your own.

NOTE: before writing your own, make sure you check out the `theme` and `transform` properties on the `ValRichText` - most simpler cases should be covered by them.

```tsx
export function ValRichText({
  children: root,
}: {
  children: RichText<MyRichTextOptions>;
}) {
  function build(
    node: RichTextNode<MyRichTextOptions>,
    key?: number
  ): JSX.Element | string {
    if (typeof node === "string") {
      return node;
    }
    // you can map the classes to something else here
    const className = node.classes.join(" ");
    const tag = node.tag; // one of: "img" | "a" | "ul" | "ol" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "br" | "p" | "li" | "span"

    // Example of rendering img with MyOwnImageComponent:
    if (tag === "img") {
      return <MyOwnImageComponent {...node} />;
    }
    return React.createElement(
      tag,
      {
        key,
        className,
      },
      "children" in node ? node.children.map(build) : null
    );
  }
  return <div {...val.attrs(root)}>{root.children.map(build)}</div>;
}
type MyRichTextOptions = AnyRichTextOptions; // you can reduce the surface of what you need to render, by restricting the `options` in `s.richtext(options)`
```

## Image

### Image Schema

```ts
s.image();
```

### Initializing image content

Local images must be stored under the `.public` folder.

```ts
import { s, c } from "../val.config";

export const schema = s.image();

export default c.define("/image", schema, c.file("/public/myfile.jpg"));
```

**NOTE**: This will not validate, since images requires `width`, `height` and a `sha256` checksum. You can fix validation errors like this by using the CLI or by using the VS Code plugin.

### Rendering images

The `ValImage` component is a wrapper around `next/image` that accepts a Val `Image` type.

You can use it like this:

```tsx
const content = useVal(contentVal);

return <ValImage src={content.image} alt={content.alt} />;
```

### Using images in components

Images are transformed to object that have a `url` property which can be used to render them.

Example:

```tsx
// in a Functional Component
const image = useVal(imageVal);

return <img src={image.url} />;
```

## Union

The union schema can be used to create either "tagged unions" or a union of string literals.

### Union Schema tagged unions

A tagged union is a union of objects which all have the same field (of the same type). This field can be used to determine (or "discriminate") the exact type of one of the types of the union.

It is useful when editors should be able to chose from a set of objects that are different.

Example: let us say you have a page that can be one of the following: blog (page) or product (page). In this case your schema could look like this:

```ts
s.union(
  "type", // the key of the "discriminator"
  s.object({
    type: s.literal("blogPage"), // <- each type must have a UNIQUE value
    author: s.string(),
    // ...
  }),
  s.object({
    type: s.literal("productPage"),
    sku: s.number(),
    // ...
  })
); // <- Schema<{ type: "blogPage", author: string } | { type: "productPage", sku: number }>
```

## Union Schema: union of string literals

You can also use a union to create a union of string literals. This is useful if you want a type-safe way to describe a set of valid strings that can be chosen by an editor.

```ts
s.union(
  s.literal("one"),
  s.literal("two")
  //...
); // <- Schema<"one" | "two">
```

## KeyOf

If you need to reference content in another `.val` file you can use the `keyOf` schema.

### KeyOf Schema

```ts
import otherVal from "./other.val"; // NOTE: this must be an array or a record

s.keyOf(otherVal);
```

### Initializing keyOf

### Using keyOf to reference content

```tsx
const article = useVal(articleVal); // s.object({ author: s.keyOf(otherVal) })
const authors = useVal(otherVal); // s.array(s.object({ name: s.string() }))

const nameOfAuthor = authors[articleVal.author].name;
```
